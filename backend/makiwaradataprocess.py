# -*- coding: utf-8 -*-
"""MakiwaraDataProcess.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1j_1W7cUkG5hAtUibnB_XXewup0mmc27z
"""

import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import matplotlib.colors as mcolors
import numpy as np

from backend import global_vars


#from google.colab import drive
#drive.mount('/content/drive')

def peak_detection(signal, window_size=3, threshold=5.0):
    peaks = []
    for i in range(len(signal)):
        if i < window_size // 2 or i >= len(signal) - window_size // 2:
            continue
        if signal[i] == max(signal[i - window_size // 2:i + window_size // 2 + 1]) and signal[i] > threshold:
            peaks.append((i, signal[i]))
    return peaks

def secondary_force(signal_segment):
    peaks = []
    for i in range(2, len(signal_segment) - 1):
        if signal_segment[i] >= signal_segment[i-1] and signal_segment[i] >= signal_segment[i+1]:
            #print(i, signal_segment[i])
            peaks.append((i, signal_segment[i], abs(signal_segment[i-1]-signal_segment[i])))
    if len(peaks) > 0:
        return peaks
    else:
        diff = signal_segment[1] - signal_segment[0]
        for i in range(2, len(signal_segment) - 1):
            if abs(signal_segment[i] - signal_segment[i-1]) < abs(diff):
                peaks.append((i, signal_segment[i], abs(signal_segment[i-1]-signal_segment[i])))
            diff = signal_segment[i] - signal_segment[i-1]
        return peaks

def min_detection(signal, window_size=3, threshold=-5.0):
    peaks = []
    for i in range(len(signal)):
        if i < window_size // 2 or i >= len(signal) - window_size // 2:
            continue
        if signal[i] == min(signal[i - window_size // 2:i + window_size // 2 + 1]) and signal[i] < threshold:
            peaks.append((i, signal[i]))
    return peaks

def generate_time_vector(start_time, end_time, num_points):
    start_datetime = datetime.strptime(start_time, '%Y.%m.%d-%H:%M:%S.%f')
    end_datetime = datetime.strptime(end_time, '%Y.%m.%d-%H:%M:%S.%f')

    time_difference = end_datetime - start_datetime
    time_step = time_difference / (num_points - 1)

    time_vector = [start_datetime + i * time_step for i in range(num_points)]
    return time_vector

# reference point should be eg. min or max point, then if before is True: search starting point of the punch. if False: end point of... eg. end point of first sinusoidal wave's period end time
def search_zero_idx(signal, reference_point, before, threshold):
    ref = signal[reference_point]
    match before:
        case True:
            while signal[reference_point] > threshold:
                reference_point -= 1
                #for idx in reversed(range(reference_point)):
                  #if signal[idx] == 0:
                    #return idx
        case False:
            while signal[reference_point] < threshold:
                reference_point += 1
    return reference_point

def check_vibration(signal, window_size, tolerance, threshold=0.5):
    for i in range(len(signal) - window_size + 1):
        window = signal[i:i+window_size]
        mean = np.mean(window)
        std_dev = np.std(window)
        if std_dev <= tolerance and mean < threshold:
            return i + window_size - 1
    return -1

def find_index(time_vector, time_point):
    time_differences = [abs(t - time_point) for t in time_vector]
    return np.argmin(time_differences)

def calculate_timedomain_parameters(signal):
    amplitudes = np.abs(signal)
    std = np.std(amplitudes)
    mean = np.mean(amplitudes)
    skewness = np.mean((amplitudes - mean) ** 3) / np.mean((amplitudes - mean) ** 2) ** (3/2)
    kurtosis = np.mean((amplitudes - mean) ** 4) / np.mean((amplitudes - mean) ** 2) ** 2
    maximum = np.max(signal)
    minimum = np.min(signal)

    return std, mean, skewness, kurtosis, maximum, minimum

def calculate_fourier_parameters(signal, sampling_rate):

    # Fourier-transzformáció számítása
    fourier_transform = np.fft.fft(signal)

    # Frekvenciák számítása
    frequencies = np.fft.fftfreq(len(signal), d=1/sampling_rate)

    # Amplitúdók és fázisok számítása
    amplitudes = np.abs(fourier_transform)
    phases = np.angle(fourier_transform)

    # Domináns frekvenciák meghatározása
    dominant_frequencies = frequencies[np.argsort(amplitudes)[::-1][:5]]  # Az első 5 legnagyobb amplitúdójú frekvencia

    # Teljes spektrum energia
    total_energy = np.sum(amplitudes ** 2)

    # Spektrális centroid számítása
    spectral_centroid = np.sum(frequencies * amplitudes) / np.sum(amplitudes)

    # Spektrális sűrűség számítása
    spectral_density = (amplitudes ** 2 / np.sum(amplitudes))

    # Frekvenciaközök számítása
    frequency_gaps = np.diff(abs(frequencies))

    return frequencies, amplitudes, max(phases), max(dominant_frequencies), total_energy, spectral_centroid, max(spectral_density), np.mean(spectral_density), np.mean(frequency_gaps)

def dataProcess():
    start_time = '2024.04.30-01:33:43.800573'
    end_time = '2024.04.30-01:34:13.805039'
    start_time2 = '2024.04.30-01:33:43.806525'
    end_time2 = '2024.04.30-01:34:13.861598'

    df = global_vars.rawDataFrame[['X1', 'Y1', 'Z1']]
    df2 = global_vars.rawDataFrame[['X2', 'Y2', 'Z2']]

    fs = 800
    num_points = len(df['X1'])
    time_vector = generate_time_vector(start_time, end_time, num_points)

    num_points2 = len(df2['X2'])
    time_vector2 = generate_time_vector(start_time2, end_time2, num_points2)

    jel= df["Z1"]#[1, 3, 2, 5, 4, 7, 6, 9, 8, 6]
    csucsok = peak_detection(jel, 100, 15)
    minimumok = min_detection(jel, 200)

    jel2 = df2["Z2"]#[1, 3, 2, 5, 4, 7, 6, 9, 8, 6]
    csucsok2 = peak_detection(jel2, 100)
    minimumok2 = min_detection(jel2, 200, threshold=-5)
    columns = ['name', 'max_acc', 'min_acc', 'x_peak', 'x_resultant_percentage', 'punchTime', 'push1Period', 'secondaryPushAmpl', 'secondaryPushDiff', 'std', 'mean', 'skewness',
            'kurtosis', 'max_phase', 'dominant_frequency', 'total_energy', 'spectral_centroid', 'max_spectral_density',
            'mean_spectral_density', 'mean_frequency_gaps', 'max_acc_2', 'min_acc_2', 'punchTime2', 'std2', 'mean2', 'skewness2', 'kurtosis2',
            'max_phase2', 'dominant_frequencY2', 'total_energY2', 'spectral_centroid2', 'max_spectral_densitY2', 'mean_spectral_densitY2',
            'mean_frequency_gaps2']
    hitsList = []

    for i in range(len(csucsok2)):
        """subplot1 shows acceleroometer 1"""
        # calculate some values
        csucs0 = csucsok[i][0]
        csucs0val = csucsok[i][1]
        min0 = minimumok[i][0]
        min0val = minimumok[i][1]
        if csucs0 > min0:
            uj_csucs = secondary_force(df['Z1'][min0-20:min0].reset_index(drop=True))
            csucs0 = uj_csucs[0][0]+min0-20
            csucs0val = uj_csucs[0][1]
        punchFrom = search_zero_idx(df['Z1'], csucs0, before=True, threshold=1.0)
        punchWavePeriod = search_zero_idx(df['Z1'], min0, before=False, threshold=-2.0)
        deltaT = (time_vector[punchWavePeriod]-time_vector[punchFrom])
        pushPeriodStr = (datetime(1,1,1,0,0) + deltaT).strftime('%S.%f')
        checkPushTime = df['Z1'][csucs0+100:csucs0+300]
        damped = check_vibration(checkPushTime, window_size=50, tolerance=0.3, threshold=1)
        dimgray = mcolors.CSS4_COLORS['dimgray']
        violet = mcolors.CSS4_COLORS['violet']
        time_point = time_vector[punchFrom]
        index = find_index(time_vector, time_point)
        punchTime = (datetime(1,1,1,0,0) + (time_vector[csucs0+100+damped]-time_vector[punchFrom])).strftime('%S.%f')
        df_segment = df['Z1'][csucs0:min0].reset_index(drop=True)
        secondary_acc_peak = None
        if csucs0 < min0:
            secondary_acc_peak = secondary_force(df_segment)


        # plot x,y,z of each punch
        df['resultantAcc'] = np.sqrt(df['X1']**2 + df['Y1']**2 + df['Z1']**2)
        # plot secondary "forces"
        ampl = 0.0
        diff = 0.0
        

        # x iranyu gyorsulas vizsgalata az eredo erohoz kepest -- %
        x_segment_peak = peak_detection(df['X1'][csucs0-10:csucs0+300].reset_index(drop=True), threshold=1.5)
        x_segment_min = min_detection(df['X1'][csucs0-10:csucs0+300].reset_index(drop=True), threshold=-1.5)
        x_peak = None
        x_percentage_acc = 0.0
        if len(x_segment_peak) > 0 and len(x_segment_min) > 0:
            if x_segment_min[0][0] < x_segment_peak[0][0]:
                x_peak = (x_segment_min[0][0], x_segment_min[0][1])
            elif x_segment_min[0][0] > x_segment_peak[0][0]:
                x_peak = (x_segment_peak[0][0], x_segment_peak[0][1])
        elif len(x_segment_peak) > 0:
            x_peak = (x_segment_peak[0][0], x_segment_peak[0][1])
        elif len(x_segment_min) > 0:
            x_peak = (x_segment_min[0][0], x_segment_min[0][1])
        if x_peak is not None:
            x_percentage_acc = df['resultantAcc'][csucs0] / 100 * abs(x_peak[1])
        else:
            x_peak = 0



        std, mean, skewness, kurtosis, maximum, minimum = calculate_timedomain_parameters(df['Z1'][csucs0-10:csucs0+300])
        frequencies, fourier_transform, max_phase, dominant_frequency, total_energy, spectral_centroid, max_spectral_density, mean_spectral_density, mean_frequency_gaps = calculate_fourier_parameters(df['Z1'][csucs0-10:csucs0+300], 800)
        


        csucs0_2 = csucsok2[i][0]
        csucs0_2val = csucsok2[i][1]
        #csucs1 = csucsok2[i+1][0] if i < len(csucsok2) else len(csucsok2)-1
        min0_2 = minimumok2[i][0]
        min0_2val = minimumok2[i][1]
        
        checkPushTime2 = jel2[csucs0_2:csucs0_2 + 500]
        damped2 = check_vibration(checkPushTime2, window_size=50, tolerance=0.1)
        #print(damped2)
        #dimgray = mcolors.CSS4_COLORS['dimgray']
        time_point = time_vector[punchFrom]
        #index = find_index(time_vector2, time_point)
        #plt.plot(time_vector2[index], 0, 'm*')
        punchFrom2 = search_zero_idx(df2['Z2'], csucs0_2-10, before=True, threshold=1.0)
        punchTime2 = (datetime(1,1,1,0,0) + (time_vector2[csucs0_2+damped2]-time_vector2[punchFrom2])).strftime('%S.%f')
        


        std2, mean2, skewness2, kurtosis2, maximum2, minimum2 = calculate_timedomain_parameters(df2['Z2'][csucs0_2-10:csucs0_2+300])
        frequencies2, fourier_transform2, max_phase2, dominant_frequencY2, total_energY2, spectral_centroid2, max_spectral_densitY2, mean_spectral_densitY2, mean_frequency_gaps2 = calculate_fourier_parameters(df2['Z2'][csucs0_2-10:csucs0_2+300], 800)



        new_row = {'name': 'unknown', 'max_acc': csucs0val, 'min_acc': min0val, 'x_peak': x_peak[1], 'x_resultant_percentage': x_percentage_acc, 'punchTime': punchTime, 'push1Period': pushPeriodStr,
                'secondaryPushAmpl': ampl, 'secondaryPushDiff': diff, 'std': std, 'mean': mean, 'skewness': skewness, 'kurtosis': kurtosis,
                'max_phase': max_phase, 'dominant_frequency': dominant_frequency, 'total_energy': total_energy,
                'spectral_centroid': spectral_centroid, 'max_spectral_density': max_spectral_density,
                'mean_spectral_density': mean_spectral_density, 'mean_frequency_gaps': mean_frequency_gaps, 'max_acc_2': csucs0_2val,
                'min_acc_2': min0_2val, 'punchTime2': punchTime2, 'std2': std2, 'mean2': mean2, 'skewness2': skewness2, 'kurtosis2': kurtosis2,
                'max_phase2': max_phase2, 'dominant_frequencY2': dominant_frequencY2, 'total_energY2': total_energY2,
                'spectral_centroid2': spectral_centroid2, 'max_spectral_densitY2': max_spectral_densitY2,
                'mean_spectral_densitY2': mean_spectral_densitY2, 'mean_frequency_gaps2': mean_frequency_gaps2}
        hitsList.append(new_row)

    tmp = pd.DataFrame(hitsList, columns=columns)
    global_vars.currentMeasurementStats = tmp.copy()
    saveNameCsv = 'makiwaraPunches' + start_time + '.csv'
    saveNameXlsx = 'makiwaraPunches' + start_time + '.xlsx'
    global_vars.currentMeasurementStats.to_csv(saveNameCsv, mode='w', header=True, index=True)
    

